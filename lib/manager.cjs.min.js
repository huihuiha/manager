"use strict";let n=!1;class e{constructor(n){this.orderBy="DESC",this._supportEvents=["action","done","allDone"],this._eventFn={action:{},done:{},allDone:{}},this.orderBy=n,this.queue=[]}enQueue(e=(()=>{}),o={name:"",weight:0,series:!0,exec:!1,status:"wait"}){let t=this.queue.find((n=>n.actionInfo.name===o.name));t?(t.actionFn=e,t.actionInfo=Object.assign(Object.assign(Object.assign({},t.actionInfo),o),{status:"wait"}),n&&console.info("【 ActionManager log 】交互入队过程中发现交互已存在，更新交互信息",t)):(this.queue.push({actionFn:e,actionInfo:Object.assign(Object.assign({series:!0,exec:!1},o),{status:"wait"})}),n&&console.info("【 ActionManager log 】交互入队",o)),this.queue.sort(((n,e)=>"ASC"===this.orderBy?n.actionInfo.weight-e.actionInfo.weight:e.actionInfo.weight-n.actionInfo.weight)),n&&console.info("【 ActionManager log 】交互排序",this.queue)}unQueue(){let e=this.queue.find((n=>"start"===n.actionInfo.status&&n.actionInfo.series));if(e)return void(n&&console.info("【 ActionManager log 】交互正在执行，出队操作被阻止",e.actionInfo));let o=this.queue.find((n=>"wait"===n.actionInfo.status));if(!o)return n&&console.info("【 ActionManager log 】交互已全部结束"),void Object.keys(this._eventFn.allDone).forEach((e=>{n&&console.info(`【 ActionManager log 】allDone 事件监听函数 ${e} 被触发`,this.queue),this._eventFn.allDone[e].fn(this.queue),this._eventFn.allDone[e]&&this._eventFn.allDone[e].once&&(this._eventFn.allDone[e].fn=()=>{},n&&console.info(`【 ActionManager log 】allDone 事件监听函数 ${e} 被移除`,this.queue))}));n&&console.info(`【 ActionManager log 】${o.actionInfo.name} 交互执行`,o.actionInfo),o.actionInfo.status="start",o.actionFn(o.actionInfo,this.queue),o.actionInfo.series||(n&&console.info(`【 ActionManager log 】${o.actionInfo.name} 是非串行交互，故继续执行下个交互`),this.unQueue()),Object.keys(this._eventFn.action).forEach((e=>{n&&console.info(`【 ActionManager log 】action 事件监听函数 ${e} 被触发`,o.actionInfo),this._eventFn.action[e].fn(o.actionInfo,this.queue),this._eventFn.action[e]&&this._eventFn.action[e].once&&(this._eventFn.action[e].fn=()=>{},n&&console.info(`【 ActionManager log 】action 事件监听函数 ${e} 被移除`,o.actionInfo))}))}done(e=""){let o=this.queue.find((n=>n.actionInfo.name===e));o?(n&&console.info(`【 ActionManager log 】${o.actionInfo.name} 交互结束`,o.actionInfo),o.actionInfo.status="end",Object.keys(this._eventFn.done).forEach((e=>{n&&console.info(`【 ActionManager log 】done 事件监听函数 ${e} 被触发`,o.actionInfo),this._eventFn.done[e].fn(o.actionInfo,this.queue),this._eventFn.done[e]&&this._eventFn.done[e].once&&(this._eventFn.done[e].fn=()=>{},n&&console.info(`【 ActionManager log 】done 事件监听函数 ${e} 被移除`,o.actionInfo))})),this.unQueue()):n&&console.info(`【 ActionManager log 】执行 ${e} 交互结束时发生错误，在交互队列中未找到该交互！`)}on(e,o=(()=>{}),t={namespace:"",once:!1}){return"string"==typeof e&&e?"function"!=typeof o?(console.error("【 ActionManager Action.on error 】 fn must be a function!"),this):this._supportEvents.indexOf(e)<0?(console.error('【 ActionManager Action.on error 】 event only supports "action"、"done"、"allDone"!'),this):(t.namespace||(t.namespace=`${e}_fn_${Object.keys(this._eventFn[e]).length+1}`),n&&console.info(`【 ActionManager log 】注册 ${e} 事件监听函数 ${t.namespace}`,t),this._eventFn[e][t.namespace]={fn:o,once:t.once},this):(console.error("【 ActionManager Action.on error 】 event must be a string!"),this)}off(e="action",o=""){return e?this._supportEvents.indexOf(e)<0?(console.error('【 ActionManager Action.off error 】 event only supports "action"、"done"、"allDone"!'),this):""===o?(n&&console.info(`【 ActionManager log 】移除 ${e} 事件所有监听函数`),this._eventFn[e]={},this):(n&&console.info(`【 ActionManager log 】移除 ${e} 事件监听函数 ${o}`),this._eventFn[e][o].fn=()=>{},this):(n&&console.info("【 ActionManager log 】移除所有事件监听函数"),this._eventFn={action:{},done:{},allDone:{}},this)}clear(){return n&&console.info("【 ActionManager log 】清空交互队列"),this.queue.forEach((n=>{"wait"===n.actionInfo.status&&n.actionInfo.exec&&n.actionFn(n.actionInfo,this.queue)})),this.queue=[],this}}var o=new class{constructor(){this._actions={__DEFAULT__:new e},this._activated="__DEFAULT__"}debug(){n=!0}init(o="__DEFAULT__",t="DESC"){return n&&console.info(`【 ActionManager log 】初始化交互实例 ${o}`),this._actions[o]=new e(t),this.use(o),this}use(e="__DEFAULT__"){return n&&console.info(`【 ActionManager log 】激活交互实例 ${e}`),this._activated=e,this}enQueue(n=(()=>{}),e={name:"",weight:0,series:!0,exec:!1,status:"wait"}){return""===e.name?(console.error("【 ActionManager.enQueue error 】 actionInfo.name cannot be empty!"),this):(this._actions[this._activated].enQueue(n,e),this)}start(){return n&&console.info(`【 ActionManager log 】启动交互实例 ${this._activated}`),this._actions[this._activated].unQueue(),this}done(n=""){return""===n?(console.error("【 ActionManager.done error 】 actionName cannot be empty!"),this):(this._actions[this._activated].done(n),this)}on(n,e,o){return this._actions[this._activated].on(n,e,o),this}off(n="action",e="",o=""){return o=o||this._activated,this._actions[o]&&this._actions[o].off(n,e),this}clear(n){return n=n||this._activated,this._actions[n]&&this._actions[n].clear(),this}getActionQueue(n){return n=n||this._activated,this._actions[n].queue}};let t=!1;class i{constructor(){this.dialogInfo={name:"",data:{}},this._supportEvents=["show","close"],this._eventFn={show:{},close:{}}}show(n={name:"",data:{}}){t&&console.info(`【 DialogManager log 】${n.name} 被打开`),this.dialogInfo=n,Object.keys(this._eventFn.show).forEach((e=>{t&&console.info(`【 DialogManager log 】show 事件监听函数 ${e} 被触发`,n),this._eventFn.show[e].fn(n),this._eventFn.show[e]&&this._eventFn.show[e].once&&(this._eventFn.show[e].fn=()=>{},t&&console.info(`【 DialogManager log 】show 事件监听函数 ${e} 被移除`,n))}))}close(n={}){const e=JSON.parse(JSON.stringify(this.dialogInfo));t&&console.info(`【 DialogManager log 】${e.name} 被关闭`),Object.keys(this._eventFn.close).forEach((o=>{t&&console.info(`【 DialogManager log 】close 事件监听函数 ${o} 被触发`,e),this._eventFn.close[o].fn(e,n),this._eventFn.close[o]&&this._eventFn.close[o].once&&(this._eventFn.close[o].fn=()=>{},t&&console.info(`【 DialogManager log 】close 事件监听函数 ${o} 被移除`,e))}))}on(n,e=(()=>{}),o={namespace:"",once:!1}){return"string"==typeof n&&n?"function"!=typeof e?(console.error("【 DialogManager.on error 】 fn must be a function!"),this):this._supportEvents.indexOf(n)<0?(console.error('【 DialogManager.on error 】 event only supports "show"、"close"!'),this):(o.namespace||(o.namespace=`${n}_fn_${Object.keys(this._eventFn[n]).length+1}`),t&&console.info(`【 DialogManager log 】注册 ${n} 事件监听函数 ${o.namespace}`,o),this._eventFn[n][o.namespace]={fn:e,once:o.once},this):(console.error("【 DialogManager.on error 】 event must be a string!"),this)}off(n="show",e=""){return n?this._supportEvents.indexOf(n)<0?(console.error('【 DialogManager.off error 】 event only supports "show"、"close"!'),this):""===e?(t&&console.info(`【 DialogManager log 】移除 ${n} 事件所有监听函数`),this._eventFn[n]={},this):(t&&console.info(`【 DialogManager log 】移除 ${n} 事件监听函数 ${e}`),this._eventFn[n][e].fn=()=>{},this):(t&&console.info("【 DialogManager log 】移除所有事件监听函数"),this._eventFn={show:{},close:{}},this)}}var s=new class{constructor(){this._dialogs={__DEFAULT__:new i},this._activated="__DEFAULT__"}debug(){t=!0}init(n="__DEFAULT__"){return t&&console.info(`【 DialogManager log 】初始化弹窗实例 ${n}`),this._dialogs[n]=new i,this.use(n),this}use(n="__DEFAULT__"){return t&&console.info(`【 DialogManager log 】激活弹窗实例 ${n}`),this._activated=n,this}show(n){return""===n.name?(console.error("【 DialogManager.show error 】 dialogInfo.name cannot be empty!"),this):(this._dialogs[this._activated].show(n),this)}close(n={}){return this._dialogs[this._activated].close(n),this}on(n,e=(()=>{}),o={namespace:"",once:!1}){return this._dialogs[this._activated].on(n,e,o),this}off(n,e=""){return this._dialogs[this._activated].off(n,e),this}};exports.ActionManager=o,exports.DialogManager=s;

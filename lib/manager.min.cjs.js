"use strict";let e=!1;class n{constructor(e){this.orderBy="DESC",this._supportEvents=["action","done","allDone"],this._eventFn={action:{},done:{},allDone:{}},this.orderBy=e,this.queue=[]}enQueue(n=(()=>{}),o={name:"",weight:0,series:!0,exec:!1,status:"wait"}){let t=this.queue.find((e=>e.actionInfo.name===o.name));t?(t.actionFn=n,t.actionInfo=Object.assign(Object.assign(Object.assign({},t.actionInfo),o),{status:"wait"}),e&&console.info("【 ActionManager log 】交互入队过程中发现交互已存在，更新交互信息",t)):(this.queue.push({actionFn:n,actionInfo:Object.assign(Object.assign({series:!0,exec:!1},o),{status:"wait"})}),e&&console.info("【 ActionManager log 】交互入队",o)),this.queue.sort(((e,n)=>"ASC"===this.orderBy?e.actionInfo.weight-n.actionInfo.weight:n.actionInfo.weight-e.actionInfo.weight)),e&&console.info("【 ActionManager log 】交互排序",this.queue)}unQueue(){let n=this.queue.find((e=>"start"===e.actionInfo.status&&e.actionInfo.series));if(n)return void(e&&console.info("【 ActionManager log 】交互正在执行，出队操作被阻止",n.actionInfo));let o=this.queue.find((e=>"wait"===e.actionInfo.status));if(!o)return e&&console.info("【 ActionManager log 】交互已全部结束"),void Object.keys(this._eventFn.allDone).forEach((n=>{e&&console.info(`【 ActionManager log 】allDone 事件监听函数 ${n} 被触发`,this.queue),this._eventFn.allDone[n].fn(this.queue),this._eventFn.allDone[n]&&this._eventFn.allDone[n].once&&(this._eventFn.allDone[n].fn=()=>{},e&&console.info(`【 ActionManager log 】allDone 事件监听函数 ${n} 被移除`,this.queue))}));e&&console.info(`【 ActionManager log 】${o.actionInfo.name} 交互执行`,o.actionInfo),o.actionInfo.status="start",o.actionFn(o.actionInfo,this.queue),o.actionInfo.series||(e&&console.info(`【 ActionManager log 】${o.actionInfo.name} 是非串行交互，故继续执行下个交互`),this.unQueue()),Object.keys(this._eventFn.action).forEach((n=>{e&&console.info(`【 ActionManager log 】action 事件监听函数 ${n} 被触发`,o.actionInfo),this._eventFn.action[n].fn(o.actionInfo,this.queue),this._eventFn.action[n]&&this._eventFn.action[n].once&&(this._eventFn.action[n].fn=()=>{},e&&console.info(`【 ActionManager log 】action 事件监听函数 ${n} 被移除`,o.actionInfo))}))}done(n=""){let o=this.queue.find((e=>e.actionInfo.name===n));o?(e&&console.info(`【 ActionManager log 】${o.actionInfo.name} 交互结束`,o.actionInfo),o.actionInfo.status="end",Object.keys(this._eventFn.done).forEach((n=>{e&&console.info(`【 ActionManager log 】done 事件监听函数 ${n} 被触发`,o.actionInfo),this._eventFn.done[n].fn(o.actionInfo,this.queue),this._eventFn.done[n]&&this._eventFn.done[n].once&&(this._eventFn.done[n].fn=()=>{},e&&console.info(`【 ActionManager log 】done 事件监听函数 ${n} 被移除`,o.actionInfo))})),this.unQueue()):e&&console.info(`【 ActionManager log 】执行 ${n} 交互结束时发生错误，在交互队列中未找到该交互！`)}on(n,o=(()=>{}),t={namespace:"",once:!1}){return"string"==typeof n&&n?"function"!=typeof o?(console.error("【 ActionManager Action.on error 】 fn must be a function!"),this):this._supportEvents.indexOf(n)<0?(console.error('【 ActionManager Action.on error 】 event only supports "action"、"done"、"allDone"!'),this):(t.namespace||(t.namespace=`${n}_fn_${Object.keys(this._eventFn[n]).length+1}`),e&&console.info(`【 ActionManager log 】注册 ${n} 事件监听函数 ${t.namespace}`,t),this._eventFn[n][t.namespace]={fn:o,once:t.once},this):(console.error("【 ActionManager Action.on error 】 event must be a string!"),this)}off(n="action",o=""){return n?this._supportEvents.indexOf(n)<0?(console.error('【 ActionManager Action.off error 】 event only supports "action"、"done"、"allDone"!'),this):""===o?(e&&console.info(`【 ActionManager log 】移除 ${n} 事件所有监听函数`),this._eventFn[n]={},this):(e&&console.info(`【 ActionManager log 】移除 ${n} 事件监听函数 ${o}`),this._eventFn[n][o].fn=()=>{},this):(e&&console.info("【 ActionManager log 】移除所有事件监听函数"),this._eventFn={action:{},done:{},allDone:{}},this)}clear(){return e&&console.info("【 ActionManager log 】清空交互队列"),this.queue.forEach((e=>{"wait"===e.actionInfo.status&&e.actionInfo.exec&&e.actionFn(e.actionInfo,this.queue)})),this.queue=[],this}}var o=new class{constructor(){this._actions={__DEFAULT__:new n},this._activated="__DEFAULT__"}debug(){e=!0}init(o="__DEFAULT__",t="DESC"){return e&&console.info(`【 ActionManager log 】初始化交互实例 ${o}`),this._actions[o]=new n(t),this.use(o),this}use(n="__DEFAULT__"){return e&&console.info(`【 ActionManager log 】激活交互实例 ${n}`),this._activated=n,this}enQueue(e=(()=>{}),n={name:"",weight:0,series:!0,exec:!1,status:"wait"}){return""===n.name?(console.error("【 ActionManager.enQueue error 】 actionInfo.name cannot be empty!"),this):(this._actions[this._activated].enQueue(e,n),this)}start(){return e&&console.info(`【 ActionManager log 】启动交互实例 ${this._activated}`),this._actions[this._activated].unQueue(),this}done(e=""){return""===e?(console.error("【 ActionManager.done error 】 actionName cannot be empty!"),this):(this._actions[this._activated].done(e),this)}on(e,n,o){return this._actions[this._activated].on(e,n,o),this}off(e="action",n="",o=""){return o=o||this._activated,this._actions[o]&&this._actions[o].off(e,n),this}clear(e){return e=e||this._activated,this._actions[e]&&this._actions[e].clear(),this}getActionQueue(e){return e=e||this._activated,this._actions[e].queue}};let t=!1;class i{constructor(){this.dialogInfo={name:"",data:{}},this._supportEvents=["show","close"],this._eventFn={show:{},close:{}}}show(e={name:"",data:{}}){t&&console.info(`【 DialogManager log 】${e.name} 被打开`),this.dialogInfo=e,Object.keys(this._eventFn.show).forEach((n=>{t&&console.info(`【 DialogManager log 】show 事件监听函数 ${n} 被触发`,e),this._eventFn.show[n].fn(e),this._eventFn.show[n]&&this._eventFn.show[n].once&&(this._eventFn.show[n].fn=()=>{},t&&console.info(`【 DialogManager log 】show 事件监听函数 ${n} 被移除`,e))}))}close(e={}){const n=JSON.parse(JSON.stringify(this.dialogInfo));t&&console.info(`【 DialogManager log 】${n.name} 被关闭`),Object.keys(this._eventFn.close).forEach((o=>{t&&console.info(`【 DialogManager log 】close 事件监听函数 ${o} 被触发`,n),this._eventFn.close[o].fn(n,e),this._eventFn.close[o]&&this._eventFn.close[o].once&&(this._eventFn.close[o].fn=()=>{},t&&console.info(`【 DialogManager log 】close 事件监听函数 ${o} 被移除`,n))}))}on(e,n=(()=>{}),o={namespace:"",once:!1}){return"string"==typeof e&&e?"function"!=typeof n?(console.error("【 DialogManager.on error 】 fn must be a function!"),this):this._supportEvents.indexOf(e)<0?(console.error('【 DialogManager.on error 】 event only supports "show"、"close"!'),this):(o.namespace||(o.namespace=`${e}_fn_${Object.keys(this._eventFn[e]).length+1}`),t&&console.info(`【 DialogManager log 】注册 ${e} 事件监听函数 ${o.namespace}`,o),this._eventFn[e][o.namespace]={fn:n,once:o.once},this):(console.error("【 DialogManager.on error 】 event must be a string!"),this)}off(e="show",n=""){return e?this._supportEvents.indexOf(e)<0?(console.error('【 DialogManager.off error 】 event only supports "show"、"close"!'),this):""===n?(t&&console.info(`【 DialogManager log 】移除 ${e} 事件所有监听函数`),this._eventFn[e]={},this):(t&&console.info(`【 DialogManager log 】移除 ${e} 事件监听函数 ${n}`),this._eventFn[e][n].fn=()=>{},this):(t&&console.info("【 DialogManager log 】移除所有事件监听函数"),this._eventFn={show:{},close:{}},this)}}var s=new class{constructor(){this._dialogs={__DEFAULT__:new i},this._activated="__DEFAULT__"}debug(){t=!0}init(e="__DEFAULT__"){return t&&console.info(`【 DialogManager log 】初始化弹窗实例 ${e}`),this._dialogs[e]=new i,this.use(e),this}use(e="__DEFAULT__"){return t&&console.info(`【 DialogManager log 】激活弹窗实例 ${e}`),this._activated=e,this}show(e){return""===e.name?(console.error("【 DialogManager.show error 】 dialogInfo.name cannot be empty!"),this):(this._dialogs[this._activated].show(e),this)}close(e={}){return this._dialogs[this._activated].close(e),this}on(e,n=(()=>{}),o={namespace:"",once:!1}){return this._dialogs[this._activated].on(e,n,o),this}off(e,n=""){return this._dialogs[this._activated].off(e,n),this}};let a=!1;var r=new class{constructor(){this._events={}}debug(){a=!0}batch(e=[],n=""){return e.forEach((e=>{this.on(e[0],e[1],n)})),this}on(e={eventName:"",payloadFn:()=>!0,trigger:[],listener:{}},n,o){const{eventName:t,listener:i,payloadFn:s,trigger:r}=e;return t?"function"!=typeof n?(console.error("【 EventManager on error 】 fn must be a function!"),this):i[o]?(this._events[t]||(this._events[t]={eventName:t,payloadFn:s,trigger:r,listener:i},a&&console.info(`【 EventManager log 】监听者 ${o} 创建了 ${t} 事件`,this._events[t])),this._events[t].listener[o].fn=n,a&&console.info(`【 EventManager log 】监听者 ${o} 注册了 ${t} 事件监听函数`,this._events[t].listener[o]),this):(console.error(`【 EventManager on error 】 ${o} not found in eventInfo.listener!`),this):(console.error("【 EventManager on error 】 eventInfo.eventName cannot be empty!"),this)}emit(e={eventName:"",payloadFn:()=>!0,trigger:[],listener:{}},n,o){const{eventName:t,payloadFn:i,trigger:s,listener:r}=e;return t?"function"!=typeof i?(console.error("【 EventManager emit error 】 eventInfo.payloadFn must be a function!"),this):s.find((e=>e===o))?i(n)?this._events[t]?(a&&console.info(`【 EventManager log 】${o} 触发了 ${t} 事件`,n,{eventName:t,payloadFn:i,trigger:s,listener:r}),Object.keys(this._events[t].listener).forEach((e=>{a&&console.info(`【 EventManager log 】${t} 事件监听者 ${e} 被触发`,n),this._events[t].listener[e].fn?this._events[t].listener[e].fn(n):console.warn(`【 EventManager emit warn 】 ${t} 事件监听者 ${e} 尚未注册!`),this._events[t].listener[e].once&&(this._events[t].listener[e].fn=()=>{},a&&console.info(`【 EventManager log 】${t} 事件监听者 ${e} 被移除`,n))})),this):(console.warn(`【 EventManager emit warn 】 ${t} 事件尚未创建!`),this):(console.error("【 EventManager emit error 】 Invalid payload parameter"),this):(console.error(`【 EventManager emit error 】 ${o} no permission to trigger!`),this):(console.error("【 EventManager emit error 】 eventInfo.eventName cannot be empty!"),this)}off(e="",n){return""===e?(a&&console.info("【 EventManager log 】移除所有事件监听函数"),this._events={},this):""===n?(a&&console.info(`【 EventManager log 】移除 ${e} 事件所有监听函数`),delete this._events[e].listener,this):(a&&console.info(`【 EventManager log 】移除 ${e} 事件监听函数 ${n}`),this._events[e].listener[n].fn=()=>{},this)}};exports.ActionManager=o,exports.DialogManager=s,exports.EventManager=r;
